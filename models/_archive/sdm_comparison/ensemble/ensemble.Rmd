---
title: "R Notebook"
---

# Setup
## Load packages, etc.
```{r, include = FALSE}
library(dplyr)
library(sdm)
library(terra)
library(scales)
library(lubridate)
library(leaflet)
library(vctrs)

if(!dir.exists("inputs")){dir.create("inputs")}
if(!dir.exists("outputs")){dir.create("outputs")}
grid <- rast("../../../grid/outputs/grid_250m.tif")
```

## Install packages for ensemble modelling (if not already installled)
```{r}
#sdm::installAll(update = TRUE) # Install all modeling packages if not done already
sdm::getmethodNames()
```

## Import predictors
```{r}
l <- list.files("../input_data/predictors", full.names = T, pattern = "\\.tif$")
preds <- rast(l)
names(preds) <- tools::file_path_sans_ext(basename(l))
```

## Import observations
```{r}
spec <- "Macoma balthica"
sdir <- paste0("outputs/", gsub(" ", "_", spec))
if(!dir.exists(sdir)){dir.create(sdir)}
mod_dir <- paste0(sdir, "/", gsub(" ", "_", spec), "_model.sdm")
obs_dir <- paste0("../input_data/observations/", gsub(" ", "_", spec), "_observations.csv")
obs <- read.csv(obs_dir)
obs <- vect(obs, geom = c("long", "lat"), crs="+proj=longlat +datum=WGS84")
obs <- project(obs, crs(preds))
obs_df <- as.data.frame(obs)
```

## Generate the model
```{r}
dat <- sdmData(formula = count~., train = obs[,1], predictors = preds)
dat
mod <- sdm(count~., data = dat, methods = c("svm", "brt", "gam", "glm", "rbf"), 
           replicatin ='sub', test.percent = 30, n = 1)
write.sdm(mod, mod_dir, overwrite = T)
mod
```

## Import model (if necessary) and examine ROC curve
```{r}
mod <- read.sdm(mod_dir)

png(file = paste0(sdir, "/", gsub(" ", "_", spec), "_roc.tif"))
roc(mod)
dev.off()
```

## Generate model predictions for each method
```{r}
ncores <- 8

# In parallel
p <- predict(mod, newdata = preds, 
             parallelSetting = list(ncore = ncores))

# Non parallel
#p <- predict(mod, newdata = preds)

plot(p)
```

## Generate ensemble predictions
```{r}
e <- ensemble(mod, newdata = p, setting=list(method='weighted', stat="TSS"))
temp <- project(e, "EPSG:3857", method = "near")
if(plot_agg > 1){temp <- aggregate(temp, fact = plot_agg, fun = "max")} # Decrease resolution for plotting
plet(temp, tiles=c("Esri.WorldImagery"), maxcell=ncell(temp))

png(file = paste0(sdir, "/", gsub(" ", "_", spec), "_ensemble_map.png"),
    width = 1800,
    height = 2000,
    units = "px",
    pointsize = 8,
    res = 300)
terra::plot(e)
dev.off()
```

## Convert to presence/absence based on threshold
```{r}
presab <- pa(e, mod, id = "ensemble", opt = 2) # opt specifies the threshold method
temp <- project(presab, "EPSG:3857", method = "near")
if(plot_agg > 1){temp <- aggregate(temp, fact = plot_agg, fun = "max")} # Decrease resolution for plotting
plet(temp, tiles=c("Esri.WorldImagery"), maxcell=ncell(temp))
```

## Variable importance and response curves
```{r}
vi <- getVarImp(mod, id = "ensemble", wtest = "training")
vi
plot(vi, "auc")
temp <- vi@varImportance
temp$AUCtest <- temp$AUCtest * 100
temp$corTest <- temp$corTest * 100
write.csv(temp, paste0(sdir, "/", gsub(" ", "_", spec), "_var_importance.csv"), row.names = FALSE)
```

## Response curves
```{r}
cat_preds <- c("biozone_resample_250m", "sediment_resample_250m")
cont_preds <- setdiff(names(preds), cat_preds)

rc <- getResponseCurve(mod, id = "ensemble")

# Export categorical response curves
pdf(file = paste0(sdir, "/", gsub(" ", "_", spec), "_factor_resp_curves.pdf"),
    width = 6,
    height = length(cat_preds)*6)

par(mfrow = c(length(cat_preds), 1), mar = c(12, 5, 5, 5))

for(i in 1:length(cat_preds)){
  plot(rc@response[[cat_preds[i]]], ylim = c(0,1), las = 2, main = cat_preds[i],
       xlab = "")
}

dev.off()

# Export continuous response curves
pdf(file = paste0(sdir, "/", gsub(" ", "_", spec), "_cont_resp_curves.pdf"),
    width = length(cont_preds)*3,
    height = 3)
rcurve(mod, id = "ensemble", n = cont_preds)
dev.off()
```


## Modify according to thresholds (if desired)
```{r}
# Import depth
dep <- preds[["depth_250m"]]

# Here there are two options:
# Option 1: Remove predictions from grid cells with a depth greater than
# where the species has been observed OR
# Option 2: Remove predictions from grid cells with a depth greater than
# where sampling occurred (i.e. even if the species was absent)

# Option 1
depth_thresh <- max(obs_df$depth_250m[obs_df$count > 0], na.rm = TRUE)

# Option 2
#depth_thresh <- max(obs_df$depth_250m, na.rm = TRUE)

# Implement depth threshold (if desired)
e[dep > depth_thresh] <- 0; presab[dep > depth_thresh] <- 0

# Plot
temp <- project(e, "EPSG:3857", method = "near")
if(plot_agg > 1){temp <- aggregate(temp, fact = plot_agg, fun = "max")} # Decrease resolution for plotting
plet(temp, tiles=c("Esri.WorldImagery"), maxcell=ncell(temp))

temp <- project(presab, "EPSG:3857", method = "near")
if(plot_agg > 1){temp <- aggregate(temp, fact = plot_agg, fun = "max")} # Decrease resolution for plotting
plet(temp, tiles=c("Esri.WorldImagery"), maxcell=ncell(temp))
```

## Export model predictions
```{r}
# Scale 0 to 100 and convert to integer to reduce file size
e <- e*100
fp <- paste0(sdir, "/", gsub(" ", "_", spec), "_ensemble_probability.tif")
writeRaster(e, fp, overwrite = TRUE, 
            datatype = "INT2S", gdal=c("COMPRESS=ZSTD", "PREDICTOR=2"))

fp <- paste0(sdir, "/", gsub(" ", "_", spec), "_ensemble_pa.tif")
writeRaster(presab, fp, overwrite = TRUE, 
            datatype = "INT2S", gdal=c("COMPRESS=ZSTD", "PREDICTOR=2"))
```


```{r}

```





